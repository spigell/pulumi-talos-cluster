// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package taloscluster

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/spigell/pulumi-talos-cluster/sdk/go/talos-cluster/internal"
)

// Apply the configuration to nodes.
type Apply struct {
	pulumi.ResourceState

	Credentials CredentialsOutput `pulumi:"credentials"`
}

// NewApply registers a new resource with the given unique name, arguments, and options.
func NewApply(ctx *pulumi.Context,
	name string, args *ApplyArgs, opts ...pulumi.ResourceOption) (*Apply, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ApplyMachines == nil {
		return nil, errors.New("invalid value for required argument 'ApplyMachines'")
	}
	if args.ClientConfiguration == nil {
		return nil, errors.New("invalid value for required argument 'ClientConfiguration'")
	}
	if args.SkipInitApply == nil {
		args.SkipInitApply = pulumi.BoolPtr(false)
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Apply
	err := ctx.RegisterRemoteComponentResource("talos-cluster:index:Apply", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type applyArgs struct {
	// The machine configurations to apply.
	ApplyMachines ApplyMachines `pulumi:"applyMachines"`
	// Client configuration for bootstrapping and applying resources.
	ClientConfiguration ClientConfiguration `pulumi:"clientConfiguration"`
	// skipInitApply indicates that machines will be managed or configured by external tools.
	// For example, it can serve as a source for userdata in cloud provider setups.
	// This option helps accelerate node provisioning.
	// Default is false.
	SkipInitApply *bool `pulumi:"skipInitApply"`
}

// The set of arguments for constructing a Apply resource.
type ApplyArgs struct {
	// The machine configurations to apply.
	ApplyMachines ApplyMachinesInput
	// Client configuration for bootstrapping and applying resources.
	ClientConfiguration ClientConfigurationInput
	// skipInitApply indicates that machines will be managed or configured by external tools.
	// For example, it can serve as a source for userdata in cloud provider setups.
	// This option helps accelerate node provisioning.
	// Default is false.
	SkipInitApply pulumi.BoolPtrInput
}

func (ApplyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*applyArgs)(nil)).Elem()
}

type ApplyInput interface {
	pulumi.Input

	ToApplyOutput() ApplyOutput
	ToApplyOutputWithContext(ctx context.Context) ApplyOutput
}

func (*Apply) ElementType() reflect.Type {
	return reflect.TypeOf((**Apply)(nil)).Elem()
}

func (i *Apply) ToApplyOutput() ApplyOutput {
	return i.ToApplyOutputWithContext(context.Background())
}

func (i *Apply) ToApplyOutputWithContext(ctx context.Context) ApplyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplyOutput)
}

// ApplyArrayInput is an input type that accepts ApplyArray and ApplyArrayOutput values.
// You can construct a concrete instance of `ApplyArrayInput` via:
//
//	ApplyArray{ ApplyArgs{...} }
type ApplyArrayInput interface {
	pulumi.Input

	ToApplyArrayOutput() ApplyArrayOutput
	ToApplyArrayOutputWithContext(context.Context) ApplyArrayOutput
}

type ApplyArray []ApplyInput

func (ApplyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Apply)(nil)).Elem()
}

func (i ApplyArray) ToApplyArrayOutput() ApplyArrayOutput {
	return i.ToApplyArrayOutputWithContext(context.Background())
}

func (i ApplyArray) ToApplyArrayOutputWithContext(ctx context.Context) ApplyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplyArrayOutput)
}

// ApplyMapInput is an input type that accepts ApplyMap and ApplyMapOutput values.
// You can construct a concrete instance of `ApplyMapInput` via:
//
//	ApplyMap{ "key": ApplyArgs{...} }
type ApplyMapInput interface {
	pulumi.Input

	ToApplyMapOutput() ApplyMapOutput
	ToApplyMapOutputWithContext(context.Context) ApplyMapOutput
}

type ApplyMap map[string]ApplyInput

func (ApplyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Apply)(nil)).Elem()
}

func (i ApplyMap) ToApplyMapOutput() ApplyMapOutput {
	return i.ToApplyMapOutputWithContext(context.Background())
}

func (i ApplyMap) ToApplyMapOutputWithContext(ctx context.Context) ApplyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplyMapOutput)
}

type ApplyOutput struct{ *pulumi.OutputState }

func (ApplyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Apply)(nil)).Elem()
}

func (o ApplyOutput) ToApplyOutput() ApplyOutput {
	return o
}

func (o ApplyOutput) ToApplyOutputWithContext(ctx context.Context) ApplyOutput {
	return o
}

func (o ApplyOutput) Credentials() CredentialsOutput {
	return o.ApplyT(func(v *Apply) CredentialsOutput { return v.Credentials }).(CredentialsOutput)
}

type ApplyArrayOutput struct{ *pulumi.OutputState }

func (ApplyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Apply)(nil)).Elem()
}

func (o ApplyArrayOutput) ToApplyArrayOutput() ApplyArrayOutput {
	return o
}

func (o ApplyArrayOutput) ToApplyArrayOutputWithContext(ctx context.Context) ApplyArrayOutput {
	return o
}

func (o ApplyArrayOutput) Index(i pulumi.IntInput) ApplyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Apply {
		return vs[0].([]*Apply)[vs[1].(int)]
	}).(ApplyOutput)
}

type ApplyMapOutput struct{ *pulumi.OutputState }

func (ApplyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Apply)(nil)).Elem()
}

func (o ApplyMapOutput) ToApplyMapOutput() ApplyMapOutput {
	return o
}

func (o ApplyMapOutput) ToApplyMapOutputWithContext(ctx context.Context) ApplyMapOutput {
	return o
}

func (o ApplyMapOutput) MapIndex(k pulumi.StringInput) ApplyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Apply {
		return vs[0].(map[string]*Apply)[vs[1].(string)]
	}).(ApplyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ApplyInput)(nil)).Elem(), &Apply{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApplyArrayInput)(nil)).Elem(), ApplyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApplyMapInput)(nil)).Elem(), ApplyMap{})
	pulumi.RegisterOutputType(ApplyOutput{})
	pulumi.RegisterOutputType(ApplyArrayOutput{})
	pulumi.RegisterOutputType(ApplyMapOutput{})
}
